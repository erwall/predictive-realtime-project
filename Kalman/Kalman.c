/*
 * Kalman.c
 *
 * Code generation for function 'Kalman'
 *
 * C source code generated on: Sun May 15 12:12:16 2016
 *
 */

/* Include files */
#include "rt_nonfinite.h"
#include "Kalman.h"
#include "inv.h"
#include "mrdivide.h"
#include "Kalman_data.h"

/* Type Definitions */

/* Named Constants */

/* Variable Declarations */

/* Variable Definitions */
static real_T xhat[10];
static real_T xhatm[10];
static real_T xhatm_e[16];
static real_T xhat_ext[16];
static real_T Pp[100];
static real_T Pp_ext[256];
static real_T K[20];
static real_T K_e[32];
static real_T init_10;
static real_T init_16;
static real_T init_extended;

/* Function Declarations */

/* Function Definitions */
void Kalman(char_T option, real_T b_y1, real_T y2, real_T u1, real_T u2, real_T
            return_value[16])
{
  int32_T j;
  real_T y[2];
  real_T u[2];
  real_T A[100];
  int32_T i0;
  int32_T i1;
  static const real_T b_A[100] = { 3.111, 0.08268, -3.182, -0.2245, 0.8211,
    0.1541, 0.455, 0.02951, -0.2051, -0.04261, 0.429, 2.794, -0.9092, -2.631,
    0.3671, 0.8153, 0.2896, 0.06612, -0.1762, -0.04461, 1.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 };

  real_T Pm[100];
  real_T d0;
  static const real_T B[100] = { 3.111, 0.429, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.08268, 2.794, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -3.182, -0.9092,
    0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.2245, -2.631, 0.0, 0.0, 0.0, 1.0,
    0.0, 0.0, 0.0, 0.0, 0.8211, 0.3671, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0,
    0.1541, 0.8153, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.455, 0.2896, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.02951, 0.06612, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 1.0, -0.2051, -0.1762, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    -0.04261, -0.04461, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };

  static const int8_T Q[100] = { 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 5 };

  real_T c_A[20];
  static const int8_T d_A[20] = { 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0 };

  real_T e_A[4];
  static const int8_T b_B[20] = { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
    0, 0, 0, 0 };

  static const int8_T R_e[4] = { 1, 0, 0, 1 };

  real_T b[4];
  real_T b_y[2];
  real_T f_A[10];
  real_T g_A[10];
  static const real_T h_A[20] = { 0.0008364, 0.0008679, 0.0009015, 0.0006347,
    0.001133, -0.002024, -0.001292, 0.0003297, 0.0, 0.0, -0.0004057, -0.0001901,
    -0.0009729, -9.547E-5, 0.002063, 5.49E-5, -0.0003008, -0.0003316, 0.0, 0.0 };

  int8_T I[100];
  real_T dv0[100];
  static const real_T c_y[10] = { -0.0005137700000000002, -0.0015259000000000002,
    0.0017494199999999998, -0.001303169, -0.011930000000000001,
    0.0052287300000000009, 0.00478184, 0.0005356899999999998, 0.0, 0.0 };

  real_T dv1[100];
  static const real_T dv2[16] = { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 0.5, 0.5, 0.5, 0.5, 0.1, 0.1 };

  real_T i_A[256];
  static const real_T j_A[256] = { 3.111, 0.08268, -3.182, -0.2245, 0.8211,
    0.1541, 0.455, 0.02951, -0.2051, -0.04261, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.429, 2.794, -0.9092, -2.631, 0.3671, 0.8153, 0.2896, 0.06612, -0.1762,
    -0.04461, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0,
    0.0, 0.0, 0.0, 0.0008364, 0.0008679, 0.0009015, 0.0006347, 0.001133,
    -0.002024, -0.001292, 0.0003297, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0,
    -0.0004057, -0.0001901, -0.0009729, -9.547E-5, 0.002063, 5.49E-5, -0.0003008,
    -0.0003316, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 };

  real_T Pm_e[256];
  static const real_T c_B[256] = { 3.111, 0.429, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0008364, -0.0004057, 1.0, 0.0, 0.08268, 2.794, 0.0,
    1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0008679, -0.0001901, 0.0, 1.0,
    -3.182, -0.9092, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0009015,
    -0.0009729, 0.0, 0.0, -0.2245, -2.631, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0006347, -9.547E-5, 0.0, 0.0, 0.8211, 0.3671, 0.0, 0.0, 0.0,
    0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.001133, 0.002063, 0.0, 0.0, 0.1541,
    0.8153, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, -0.002024, 5.49E-5,
    0.0, 0.0, 0.455, 0.2896, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0,
    -0.001292, -0.0003008, 0.0, 0.0, 0.02951, 0.06612, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 1.0, 0.0, 0.0, 0.0003297, -0.0003316, 0.0, 0.0, -0.2051, -0.1762,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    -0.04261, -0.04461, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 };

  static const real_T Q_e[256] = { 5.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 5.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 5.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 5.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 5.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 5.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 5.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 5.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 5.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 5.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 2.5, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 2.5, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    2.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 2.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5 };

  real_T b_Pm_e[32];
  static const int8_T d_B[32] = { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 };

  real_T k_A[32];
  static const int8_T l_A[32] = { 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 };

  real_T dv3[32];
  real_T m_A[16];
  real_T n_A[16];
  static const real_T o_A[32] = { 0.0008364, 0.0008679, 0.0009015, 0.0006347,
    0.001133, -0.002024, -0.001292, 0.0003297, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, -0.0004057, -0.0001901, -0.0009729, -9.547E-5, 0.002063, 5.49E-5,
    -0.0003008, -0.0003316, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };

  int8_T b_I[256];
  real_T dv4[256];
  real_T dv5[32];
  static const real_T d_y[16] = { -0.0005137700000000002, -0.0015259000000000002,
    0.0017494199999999998, -0.001303169, -0.011930000000000001,
    0.0052287300000000009, 0.00478184, 0.0005356899999999998, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0 };

  real_T dv6[256];

  /* UNTITLED2 Summary of this function goes here */
  /*    Detailed explanation goes here */
  /* only designed for starting in 10 state ->16 and then staying there. */
  /* Starting in 16 might work to but no thought have been put into it. */
  /* State covariance */
  /* output covariance */
  /* State covariance */
  /* output covariance */
  /* Should save memory allocation? */
  if (!xhat_not_empty) {
    /* First function call. */
    memset(&xhat[0], 0, 10U * sizeof(real_T));
    xhat_not_empty = TRUE;
    memset(&Pp[0], 0, 100U * sizeof(real_T));
    for (j = 0; j < 10; j++) {
      Pp[j + 10 * j] = 1000.0;

      /* initial covariance */
      xhatm[j] = 0.0;
    }

    memset(&xhatm_e[0], 0, sizeof(real_T) << 4);
    memset(&K[0], 0, 20U * sizeof(real_T));
    memset(&K_e[0], 0, sizeof(real_T) << 5);
    init_10 = 0.0;
    init_16 = 0.0;
    init_extended = 0.0;
    memset(&Pp_ext[0], 0, sizeof(real_T) << 8);
    for (j = 0; j < 16; j++) {
      Pp_ext[j + (j << 4)] = 1000.0;

      /* Will be reinitalized alter */
      xhat_ext[j] = 0.0;
    }

    /* Will be reinitalized alter */
  }

  /* Fix inputs. */
  y[0] = b_y1;
  y[1] = y2;
  u[0] = u1;
  u[1] = u2;
  if ((real_T)option == 1.0) {
    /* update prediction 10 states */
    init_10 = 1.0;
    for (j = 0; j < 10; j++) {
      xhatm[j] = 0.0;
      for (i0 = 0; i0 < 10; i0++) {
        A[j + 10 * i0] = 0.0;
        for (i1 = 0; i1 < 10; i1++) {
          A[j + 10 * i0] += b_A[j + 10 * i1] * Pp[i1 + 10 * i0];
        }
      }
    }

    for (i0 = 0; i0 < 10; i0++) {
      for (i1 = 0; i1 < 10; i1++) {
        d0 = 0.0;
        for (j = 0; j < 10; j++) {
          d0 += A[i0 + 10 * j] * B[j + 10 * i1];
        }

        Pm[i0 + 10 * i1] = d0 + (real_T)Q[i0 + 10 * i1];
      }
    }

    for (i0 = 0; i0 < 2; i0++) {
      for (i1 = 0; i1 < 10; i1++) {
        c_A[i0 + (i1 << 1)] = 0.0;
        for (j = 0; j < 10; j++) {
          c_A[i0 + (i1 << 1)] += (real_T)d_A[i0 + (j << 1)] * Pm[j + 10 * i1];
        }
      }
    }

    for (i0 = 0; i0 < 2; i0++) {
      for (i1 = 0; i1 < 2; i1++) {
        d0 = 0.0;
        for (j = 0; j < 10; j++) {
          d0 += c_A[i0 + (j << 1)] * (real_T)b_B[j + 10 * i1];
        }

        e_A[i0 + (i1 << 1)] = d0 + (real_T)R_e[i0 + (i1 << 1)];
      }
    }

    inv(e_A, b);
    for (i0 = 0; i0 < 10; i0++) {
      for (i1 = 0; i1 < 2; i1++) {
        c_A[i0 + 10 * i1] = 0.0;
        for (j = 0; j < 10; j++) {
          c_A[i0 + 10 * i1] += Pm[i0 + 10 * j] * (real_T)b_B[j + 10 * i1];
        }
      }

      for (i1 = 0; i1 < 2; i1++) {
        K[i0 + 10 * i1] = 0.0;
        for (j = 0; j < 2; j++) {
          K[i0 + 10 * i1] += c_A[i0 + 10 * j] * b[j + (i1 << 1)];
        }
      }
    }

    for (i0 = 0; i0 < 2; i0++) {
      b_y[i0] = u[i0] - (2.7 + 1.5999999999999996 * (real_T)i0);
    }

    for (i0 = 0; i0 < 10; i0++) {
      f_A[i0] = 0.0;
      for (i1 = 0; i1 < 10; i1++) {
        f_A[i0] += b_A[i0 + 10 * i1] * xhat[i1];
      }

      g_A[i0] = 0.0;
      for (i1 = 0; i1 < 2; i1++) {
        g_A[i0] += h_A[i0 + 10 * i1] * b_y[i1];
      }

      xhatm[i0] = f_A[i0] + g_A[i0];
    }

    /* precompute */
    memset(&I[0], 0, 100U * sizeof(int8_T));
    for (j = 0; j < 10; j++) {
      I[j + 10 * j] = 1;
    }

    for (i0 = 0; i0 < 10; i0++) {
      for (i1 = 0; i1 < 10; i1++) {
        d0 = 0.0;
        for (j = 0; j < 2; j++) {
          d0 += K[i0 + 10 * j] * (real_T)d_A[j + (i1 << 1)];
        }

        A[i0 + 10 * i1] = (real_T)I[i0 + 10 * i1] - d0;
      }
    }

    for (i0 = 0; i0 < 10; i0++) {
      for (i1 = 0; i1 < 10; i1++) {
        Pp[i0 + 10 * i1] = 0.0;
        for (j = 0; j < 10; j++) {
          Pp[i0 + 10 * i1] += A[i0 + 10 * j] * Pm[j + 10 * i1];
        }
      }
    }

    /* Symmetry */
    for (i0 = 0; i0 < 10; i0++) {
      for (i1 = 0; i1 < 10; i1++) {
        dv0[i1 + 10 * i0] = (Pp[i1 + 10 * i0] + Pp[i0 + 10 * i1]) / 2.0;
      }
    }

    for (i0 = 0; i0 < 10; i0++) {
      memcpy(&Pp[10 * i0], &dv0[10 * i0], 10U * sizeof(real_T));
      return_value[i0] = xhat[i0];
    }

    for (j = 0; j < 6; j++) {
      return_value[j + 10] = 0.0;
    }
  } else if ((real_T)option == 2.0) {
    /* update measurement 10 states */
    if (!(init_10 != 0.0)) {
      /* This might give some very minor input-output delay for first function call */
      /* But doesnt let the user make mistakes. */
      init_10 = 1.0;
      for (j = 0; j < 10; j++) {
        xhatm[j] = 0.0;
        for (i0 = 0; i0 < 10; i0++) {
          A[j + 10 * i0] = 0.0;
          for (i1 = 0; i1 < 10; i1++) {
            A[j + 10 * i0] += b_A[j + 10 * i1] * Pp[i1 + 10 * i0];
          }
        }
      }

      for (i0 = 0; i0 < 10; i0++) {
        for (i1 = 0; i1 < 10; i1++) {
          d0 = 0.0;
          for (j = 0; j < 10; j++) {
            d0 += A[i0 + 10 * j] * B[j + 10 * i1];
          }

          Pm[i0 + 10 * i1] = d0 + (real_T)Q[i0 + 10 * i1];
        }
      }

      for (i0 = 0; i0 < 2; i0++) {
        for (i1 = 0; i1 < 10; i1++) {
          c_A[i0 + (i1 << 1)] = 0.0;
          for (j = 0; j < 10; j++) {
            c_A[i0 + (i1 << 1)] += (real_T)d_A[i0 + (j << 1)] * Pm[j + 10 * i1];
          }
        }
      }

      for (i0 = 0; i0 < 2; i0++) {
        for (i1 = 0; i1 < 2; i1++) {
          d0 = 0.0;
          for (j = 0; j < 10; j++) {
            d0 += c_A[i0 + (j << 1)] * (real_T)b_B[j + 10 * i1];
          }

          e_A[i0 + (i1 << 1)] = d0 + (real_T)R_e[i0 + (i1 << 1)];
        }
      }

      inv(e_A, b);
      for (i0 = 0; i0 < 10; i0++) {
        for (i1 = 0; i1 < 2; i1++) {
          c_A[i0 + 10 * i1] = 0.0;
          for (j = 0; j < 10; j++) {
            c_A[i0 + 10 * i1] += Pm[i0 + 10 * j] * (real_T)b_B[j + 10 * i1];
          }
        }

        for (i1 = 0; i1 < 2; i1++) {
          K[i0 + 10 * i1] = 0.0;
          for (j = 0; j < 2; j++) {
            K[i0 + 10 * i1] += c_A[i0 + 10 * j] * b[j + (i1 << 1)];
          }
        }
      }

      for (i0 = 0; i0 < 10; i0++) {
        d0 = 0.0;
        for (i1 = 0; i1 < 10; i1++) {
          d0 += b_A[i0 + 10 * i1] * xhat[i1];
        }

        xhatm[i0] = d0 + c_y[i0];
      }

      /* precompute */
      memset(&I[0], 0, 100U * sizeof(int8_T));
      for (j = 0; j < 10; j++) {
        I[j + 10 * j] = 1;
      }

      for (i0 = 0; i0 < 10; i0++) {
        for (i1 = 0; i1 < 10; i1++) {
          d0 = 0.0;
          for (j = 0; j < 2; j++) {
            d0 += K[i0 + 10 * j] * (real_T)d_A[j + (i1 << 1)];
          }

          A[i0 + 10 * i1] = (real_T)I[i0 + 10 * i1] - d0;
        }
      }

      for (i0 = 0; i0 < 10; i0++) {
        for (i1 = 0; i1 < 10; i1++) {
          Pp[i0 + 10 * i1] = 0.0;
          for (j = 0; j < 10; j++) {
            Pp[i0 + 10 * i1] += A[i0 + 10 * j] * Pm[j + 10 * i1];
          }
        }
      }

      /* Symmetry */
      for (i0 = 0; i0 < 10; i0++) {
        for (i1 = 0; i1 < 10; i1++) {
          dv1[i1 + 10 * i0] = (Pp[i1 + 10 * i0] + Pp[i0 + 10 * i1]) / 2.0;
        }
      }

      for (i0 = 0; i0 < 10; i0++) {
        memcpy(&Pp[10 * i0], &dv1[10 * i0], 10U * sizeof(real_T));
      }
    }

    for (i0 = 0; i0 < 2; i0++) {
      d0 = 0.0;
      for (i1 = 0; i1 < 10; i1++) {
        d0 += (real_T)d_A[i0 + (i1 << 1)] * xhatm[i1];
      }

      b_y[i0] = y[i0] - d0;
    }

    for (i0 = 0; i0 < 10; i0++) {
      d0 = 0.0;
      for (i1 = 0; i1 < 2; i1++) {
        d0 += K[i0 + 10 * i1] * b_y[i1];
      }

      xhat[i0] = xhatm[i0] + d0;
    }

    memcpy(&return_value[0], &xhat[0], 10U * sizeof(real_T));
    for (j = 0; j < 6; j++) {
      return_value[j + 10] = 0.0;
    }
  } else if ((real_T)option == 3.0) {
    /* update prediction 16 states */
    init_16 = 1.0;
    if (!(init_extended != 0.0)) {
      /* initalize  */
      init_extended = 1.0;
      memset(&xhat_ext[0], 0, sizeof(real_T) << 4);
      memcpy(&xhat_ext[0], &xhat[0], 10U * sizeof(real_T));

      /*  Predictor should be called first. */
      memset(&Pp_ext[0], 0, sizeof(real_T) << 8);
      for (j = 0; j < 16; j++) {
        Pp_ext[j + (j << 4)] = dv2[j];
      }

      /* initial covariance */
      for (i0 = 0; i0 < 10; i0++) {
        memcpy(&Pp_ext[i0 << 4], &Pp[10 * i0], 10U * sizeof(real_T));
      }
    }

    for (i0 = 0; i0 < 16; i0++) {
      for (i1 = 0; i1 < 16; i1++) {
        i_A[i0 + (i1 << 4)] = 0.0;
        for (j = 0; j < 16; j++) {
          i_A[i0 + (i1 << 4)] += j_A[i0 + (j << 4)] * Pp_ext[j + (i1 << 4)];
        }
      }
    }

    for (i0 = 0; i0 < 16; i0++) {
      for (i1 = 0; i1 < 16; i1++) {
        d0 = 0.0;
        for (j = 0; j < 16; j++) {
          d0 += i_A[i0 + (j << 4)] * c_B[j + (i1 << 4)];
        }

        Pm_e[i0 + (i1 << 4)] = d0 + Q_e[i0 + (i1 << 4)];
      }
    }

    for (i0 = 0; i0 < 16; i0++) {
      for (i1 = 0; i1 < 2; i1++) {
        b_Pm_e[i0 + (i1 << 4)] = 0.0;
        for (j = 0; j < 16; j++) {
          b_Pm_e[i0 + (i1 << 4)] += Pm_e[i0 + (j << 4)] * (real_T)d_B[j + (i1 <<
            4)];
        }
      }
    }

    for (i0 = 0; i0 < 2; i0++) {
      for (i1 = 0; i1 < 16; i1++) {
        k_A[i0 + (i1 << 1)] = 0.0;
        for (j = 0; j < 16; j++) {
          k_A[i0 + (i1 << 1)] += (real_T)l_A[i0 + (j << 1)] * Pm_e[j + (i1 << 4)];
        }
      }
    }

    for (i0 = 0; i0 < 2; i0++) {
      for (i1 = 0; i1 < 2; i1++) {
        d0 = 0.0;
        for (j = 0; j < 16; j++) {
          d0 += k_A[i0 + (j << 1)] * (real_T)d_B[j + (i1 << 4)];
        }

        e_A[i0 + (i1 << 1)] = d0 + (real_T)R_e[i0 + (i1 << 1)];
      }
    }

    mrdivide(b_Pm_e, e_A, dv3);
    memcpy(&K_e[0], &dv3[0], sizeof(real_T) << 5);
    for (i0 = 0; i0 < 2; i0++) {
      b_y[i0] = u[i0] - (2.7 + 1.5999999999999996 * (real_T)i0);
    }

    for (i0 = 0; i0 < 16; i0++) {
      m_A[i0] = 0.0;
      for (i1 = 0; i1 < 16; i1++) {
        m_A[i0] += j_A[i0 + (i1 << 4)] * xhat_ext[i1];
      }

      n_A[i0] = 0.0;
      for (i1 = 0; i1 < 2; i1++) {
        n_A[i0] += o_A[i0 + (i1 << 4)] * b_y[i1];
      }

      xhatm_e[i0] = m_A[i0] + n_A[i0];
    }

    memset(&b_I[0], 0, sizeof(int8_T) << 8);
    for (j = 0; j < 16; j++) {
      b_I[j + (j << 4)] = 1;
    }

    for (i0 = 0; i0 < 16; i0++) {
      for (i1 = 0; i1 < 16; i1++) {
        d0 = 0.0;
        for (j = 0; j < 2; j++) {
          d0 += K_e[i0 + (j << 4)] * (real_T)l_A[j + (i1 << 1)];
        }

        i_A[i0 + (i1 << 4)] = (real_T)b_I[i0 + (i1 << 4)] - d0;
      }
    }

    for (i0 = 0; i0 < 16; i0++) {
      for (i1 = 0; i1 < 16; i1++) {
        Pp_ext[i0 + (i1 << 4)] = 0.0;
        for (j = 0; j < 16; j++) {
          Pp_ext[i0 + (i1 << 4)] += i_A[i0 + (j << 4)] * Pm_e[j + (i1 << 4)];
        }
      }
    }

    /* Symmetry */
    for (i0 = 0; i0 < 16; i0++) {
      for (i1 = 0; i1 < 16; i1++) {
        dv4[i1 + (i0 << 4)] = (Pp_ext[i1 + (i0 << 4)] + Pp_ext[i0 + (i1 << 4)]) /
          2.0;
      }
    }

    for (i0 = 0; i0 < 16; i0++) {
      memcpy(&Pp_ext[i0 << 4], &dv4[i0 << 4], sizeof(real_T) << 4);

      /* xhat_ = xhat_ext;   ?? */
      return_value[i0] = xhat_ext[i0];
    }
  } else if ((real_T)option == 4.0) {
    /* update meassurement 16 states */
    if (!(init_16 != 0.0)) {
      /* This might give some very minor input-output delay for first function call */
      /* But doesnt let the user make mistakes. */
      init_16 = 1.0;
      if (!(init_extended != 0.0)) {
        /* initalize  */
        init_extended = 1.0;
        memset(&xhat_ext[0], 0, sizeof(real_T) << 4);
        memcpy(&xhat_ext[0], &xhat[0], 10U * sizeof(real_T));

        /*  Predictor should be called first. */
        memset(&Pp_ext[0], 0, sizeof(real_T) << 8);
        for (j = 0; j < 16; j++) {
          Pp_ext[j + (j << 4)] = dv2[j];
        }

        /* initial covariance */
        for (i0 = 0; i0 < 10; i0++) {
          memcpy(&Pp_ext[i0 << 4], &Pp[10 * i0], 10U * sizeof(real_T));
        }
      }

      for (i0 = 0; i0 < 16; i0++) {
        for (i1 = 0; i1 < 16; i1++) {
          i_A[i0 + (i1 << 4)] = 0.0;
          for (j = 0; j < 16; j++) {
            i_A[i0 + (i1 << 4)] += j_A[i0 + (j << 4)] * Pp_ext[j + (i1 << 4)];
          }
        }
      }

      for (i0 = 0; i0 < 16; i0++) {
        for (i1 = 0; i1 < 16; i1++) {
          d0 = 0.0;
          for (j = 0; j < 16; j++) {
            d0 += i_A[i0 + (j << 4)] * c_B[j + (i1 << 4)];
          }

          Pm_e[i0 + (i1 << 4)] = d0 + Q_e[i0 + (i1 << 4)];
        }
      }

      for (i0 = 0; i0 < 16; i0++) {
        for (i1 = 0; i1 < 2; i1++) {
          b_Pm_e[i0 + (i1 << 4)] = 0.0;
          for (j = 0; j < 16; j++) {
            b_Pm_e[i0 + (i1 << 4)] += Pm_e[i0 + (j << 4)] * (real_T)d_B[j + (i1 <<
              4)];
          }
        }
      }

      for (i0 = 0; i0 < 2; i0++) {
        for (i1 = 0; i1 < 16; i1++) {
          k_A[i0 + (i1 << 1)] = 0.0;
          for (j = 0; j < 16; j++) {
            k_A[i0 + (i1 << 1)] += (real_T)l_A[i0 + (j << 1)] * Pm_e[j + (i1 <<
              4)];
          }
        }
      }

      for (i0 = 0; i0 < 2; i0++) {
        for (i1 = 0; i1 < 2; i1++) {
          d0 = 0.0;
          for (j = 0; j < 16; j++) {
            d0 += k_A[i0 + (j << 1)] * (real_T)d_B[j + (i1 << 4)];
          }

          e_A[i0 + (i1 << 1)] = d0 + (real_T)R_e[i0 + (i1 << 1)];
        }
      }

      mrdivide(b_Pm_e, e_A, dv5);
      memcpy(&K_e[0], &dv5[0], sizeof(real_T) << 5);
      for (i0 = 0; i0 < 16; i0++) {
        d0 = 0.0;
        for (i1 = 0; i1 < 16; i1++) {
          d0 += j_A[i0 + (i1 << 4)] * xhat_ext[i1];
        }

        xhatm_e[i0] = d0 + d_y[i0];
      }

      memset(&b_I[0], 0, sizeof(int8_T) << 8);
      for (j = 0; j < 16; j++) {
        b_I[j + (j << 4)] = 1;
      }

      for (i0 = 0; i0 < 16; i0++) {
        for (i1 = 0; i1 < 16; i1++) {
          d0 = 0.0;
          for (j = 0; j < 2; j++) {
            d0 += K_e[i0 + (j << 4)] * (real_T)l_A[j + (i1 << 1)];
          }

          i_A[i0 + (i1 << 4)] = (real_T)b_I[i0 + (i1 << 4)] - d0;
        }
      }

      for (i0 = 0; i0 < 16; i0++) {
        for (i1 = 0; i1 < 16; i1++) {
          Pp_ext[i0 + (i1 << 4)] = 0.0;
          for (j = 0; j < 16; j++) {
            Pp_ext[i0 + (i1 << 4)] += i_A[i0 + (j << 4)] * Pm_e[j + (i1 << 4)];
          }
        }
      }

      /* Symmetry */
      for (i0 = 0; i0 < 16; i0++) {
        for (i1 = 0; i1 < 16; i1++) {
          dv6[i1 + (i0 << 4)] = (Pp_ext[i1 + (i0 << 4)] + Pp_ext[i0 + (i1 << 4)])
            / 2.0;
        }
      }

      for (i0 = 0; i0 < 16; i0++) {
        memcpy(&Pp_ext[i0 << 4], &dv6[i0 << 4], sizeof(real_T) << 4);
      }

      /*   xhat_ = xhat_ext;   ?? */
    }

    for (i0 = 0; i0 < 2; i0++) {
      d0 = 0.0;
      for (i1 = 0; i1 < 16; i1++) {
        d0 += (real_T)l_A[i0 + (i1 << 1)] * xhatm_e[i1];
      }

      b_y[i0] = y[i0] - d0;
    }

    for (i0 = 0; i0 < 16; i0++) {
      d0 = 0.0;
      for (i1 = 0; i1 < 2; i1++) {
        d0 += K_e[i0 + (i1 << 4)] * b_y[i1];
      }

      xhat_ext[i0] = xhatm_e[i0] + d0;
    }

    memcpy(&return_value[0], &xhat_ext[0], sizeof(real_T) << 4);
  } else {
    /* Shoudlnt happen ... */
    for (i0 = 0; i0 < 2; i0++) {
      d0 = 0.0;
      for (i1 = 0; i1 < 16; i1++) {
        d0 += (real_T)l_A[i0 + (i1 << 1)] * xhatm_e[i1];
      }

      b_y[i0] = y[i0] - d0;
    }

    for (i0 = 0; i0 < 16; i0++) {
      d0 = 0.0;
      for (i1 = 0; i1 < 2; i1++) {
        d0 += K_e[i0 + (i1 << 4)] * b_y[i1];
      }

      xhat_ext[i0] = xhatm_e[i0] + d0;
    }

    memcpy(&return_value[0], &xhat_ext[0], sizeof(real_T) << 4);
  }
}

/* End of code generation (Kalman.c) */
